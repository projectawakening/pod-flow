// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;

import { System } from "@latticexyz/world/src/System.sol";
import { StoreSwitch } from "@latticexyz/store/src/StoreSwitch.sol";
import { requireOwner } from "@latticexyz/world/src/AccessControl.sol";
// Assume worldgen puts table libraries in ./tables relative to system
import { VerifierConfig, VerifierConfigData } from "./tables/VerifierConfig.sol";
import { Groth16G1UtilsLibConfig, Groth16G1UtilsLibConfigData } from "./tables/Groth16G1UtilsLibConfig.sol";

/**
 * This file is auto-generated. Do not edit directly.
 *
 * @title Groth16 Verifier System for MUD
 * @notice This contract verifies Groth16 ZK-SNARK proofs.
 * It is a refactored version of the standard verifier generated by snarkjs.
 * The refactoring aims to overcome the Ethereum contract size limit (EIP-170 'Spurious Dragon')
 * by moving the large set of IC (Input Consistency) point multiplications into external library chunks.
 * This allows verification of proofs with a larger number of public signals than would
 * normally fit within the size limit.
 * @dev Requires configuration via the `initialize` function after deployment.
 * The verification process delegates calls to external libraries whose addresses are stored in the VerifierConfig table.
 */
contract Groth16Verifier_<%= canonicalCircuitNameUnderscores %> is System {
    // Unique ID for this specific verifier configuration within MUD
    bytes32 constant VERIFIER_ID = keccak256(abi.encodePacked("<%= canonicalCircuitName %>"));

    // --- Field Constants ---
    // Prime field modulus for the scalar field (BN254 curve order)
    uint256 constant r = 21888242871839275222246405745257275088548364400416034343698204186575808495617;
    // Prime field modulus for the base field (BN254 curve field)
    uint256 constant q = 21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // --- Core Verification Key (VK) Constants ---
    // These are the fixed points from the trusted setup for the circuit being verified.
    // G1 point (alpha) - represented as (x, y)
    uint256 constant alpha1x  = <%= vk_alpha_1[0] %>;
    uint256 constant alpha1y  = <%= vk_alpha_1[1] %>;
    // G2 point (beta) - represented as (x.re, x.im), (y.re, y.im) (Note snarkjs index swap)
    uint256 constant beta2x0  = <%= vk_beta_2[0][0] %>; // x.re
    uint256 constant beta2x1  = <%= vk_beta_2[0][1] %>; // x.im
    uint256 constant beta2y0  = <%= vk_beta_2[1][0] %>; // y.re
    uint256 constant beta2y1  = <%= vk_beta_2[1][1] %>; // y.im
    // G2 point (gamma)
    uint256 constant gamma2x0 = <%= vk_gamma_2[0][0] %>; // x.re
    uint256 constant gamma2x1 = <%= vk_gamma_2[0][1] %>; // x.im
    uint256 constant gamma2y0 = <%= vk_gamma_2[1][0] %>; // y.re
    uint256 constant gamma2y1 = <%= vk_gamma_2[1][1] %>; // y.im
    // G2 point (delta)
    uint256 constant delta2x0 = <%= vk_delta_2[0][0] %>; // x.re
    uint256 constant delta2x1 = <%= vk_delta_2[0][1] %>; // x.im
    uint256 constant delta2y0 = <%= vk_delta_2[1][0] %>; // y.re
    uint256 constant delta2y1 = <%= vk_delta_2[1][1] %>; // y.im
    // G1 point (IC[0]) - The initial point for the public input accumulation.
    uint256 constant IC0x     = <%= IC[0][0] %>;
    uint256 constant IC0y     = <%= IC[0][1] %>;

    // Configuration constants (Used for validation during initialization & loop bounds)
    uint256 constant NUM_IC_LIBS = <%= numIcLibs %>;
    uint256 constant TOTAL_PUBLIC_SIGNALS = <%= totalPublicSignals %>;

    // Function selector for the accumulation function in the IC libraries.
    bytes4 constant ACCUMULATE_SELECTOR = 0xf74380ed;

    /**
     * @notice Initializes the verifier configuration in the MUD VerifierConfig table.
     * @dev Can only be called once, restricted by the requireOwner modifier (typically namespace owner).
     * Stores the G1 utils lib address, IC lib addresses, and constants derived during generation.
     * @param _icLibAddresses Array of addresses for the deployed IC chunk libraries.
     */
    function initialize(
        address[] memory icLibAddresses
    ) public requireOwner {
        // Require NUM_IC_LIBS to be non-zero
        require(NUM_IC_LIBS != 0, "NUM_IC_LIBS must be non-zero");

        // Check if already initialized
        uint256 numICLibs = VerifierConfig.getNumICLibs(VERIFIER_ID);
        require(numICLibs == 0, "Verifier already initialized");

        // Validate inputs
        require(icLibAddresses.length == NUM_IC_LIBS, "Incorrect number of IC Lib addresses");
        for (uint256 i = 0; i < icLibAddresses.length; i++) {
            require(icLibAddresses[i] != address(0), "IC Lib address cannot be zero");
        }

        // Store configuration in the table
        VerifierConfig.set(
            VERIFIER_ID,
            NUM_IC_LIBS,
            TOTAL_PUBLIC_SIGNALS,
            icLibAddresses
        );
    }

    /**
      * @notice Verifies a Groth16 proof.
      * @param pA The proof point A (G1).
      * @param pB The proof point B (G2).
      * @param pC The proof point C (G1).
      * @param pubSignals The public signals (inputs) for the proof, starting from index 0 (maps to IC[1] onwards).
      * @return valid True if the proof is valid, false otherwise.
      * @dev This function uses delegatecall to external IC libraries to compute the vkX accumulation to preserve the Groth16 contract execution memory context.
      *   Because delegatecall could modify state, this function cannot be marked `view` even though it doesn't modify state (nor does any of its internal delegatecalls).
      *   The final pairing check is performed using the eip197 precompile (address 0x08).
      */
    function verifyProof(
        uint256[2] calldata pA,     // G1 point A
        uint256[2][2] calldata pB,  // G2 point B
        uint256[2] calldata pC,     // G1 point C
        uint256[] calldata pubSignals // Public signals (inputs)
    ) public returns (bool) {
        // --- Read Configuration from MUD Tables --- 
        // Get G1 Utils Lib Address (Singleton Table)
        Groth16G1UtilsLibConfigData memory g1Config = Groth16G1UtilsLibConfig.get();
        require(g1Config.libAddress != address(0), "G1 Utils Lib not configured");

        // Get Verifier Config Data
        VerifierConfigData memory config = VerifierConfig.get(VERIFIER_ID);
        require(config.totalPublicSignals != 0, "Verifier not initialized");

        // --- Input Validation --- 
        require(pubSignals.length == config.totalPublicSignals, "Incorrect number of public signals"); 
        
        for(uint256 i = 0; i < pubSignals.length; i++){ 
            require(pubSignals[i] < r, "Public signal not in field Fp");
        }

        // Initialize the vkX accumulator G1 point with IC[0].
        uint256[2] memory vkXAccumulator = [IC0x, IC0y];

        // --- Call IC Libraries via Delegatecall --- 
        for (uint256 i = 0; i < config.numICLibs; i++) {
            address currentICLibAddr = config.ICAddresses[i];
            bytes memory callData = abi.encodeWithSelector(
                ACCUMULATE_SELECTOR,
                g1Config.libAddress,
                vkXAccumulator,
                pubSignals
            );

            // Perform the delegatecall.
            (bool success, bytes memory returnData) = currentICLibAddr.delegatecall(callData);

            // Handle delegatecall failure. Revert with the error message from the library.
            if (!success) {
                assembly { revert(add(returnData, 0x20), mload(returnData)) }
            }
            // vkXAccumulator is updated in place after each successful delegatecall.
        }

        // --- Final Pairing Check ---
        // e(A, B) == e(alpha, beta) * e(vkX, gamma) * e(C, delta)
        // This is checked using the pairing precompile (address 0x08) by verifying:
        // e(-A, B) * e(alpha, beta) * e(vkX, gamma) * e(C, delta) == 1
        uint256[24] memory inputPoints; // Array to hold points for the pairing precompile (4 pairs * 6 uints/pair)

        // Fill inputPoints array for pairing check:
        // Pair 1: (-A, B)
        inputPoints[0] = pA[0];
        inputPoints[1] = q - pA[1]; // Negate A's y-coordinate (in G1)
        inputPoints[2] = pB[0][1]; // B.x.im
        inputPoints[3] = pB[0][0]; // B.x.re
        inputPoints[4] = pB[1][1]; // B.y.im
        inputPoints[5] = pB[1][0]; // B.y.re
        // Pair 2: (alpha1, beta2)
        inputPoints[6] = alpha1x;
        inputPoints[7] = alpha1y;
        inputPoints[8]  = beta2x1; // beta2.x.im (Indices deliberately swapped to match snarkjs template)
        inputPoints[9]  = beta2x0; // beta2.x.re
        inputPoints[10] = beta2y1; // beta2.y.im
        inputPoints[11] = beta2y0; // beta2.y.re
        // Pair 3: (vkX, gamma2)
        inputPoints[12] = vkXAccumulator[0]; // vkX.x (result from IC library calls)
        inputPoints[13] = vkXAccumulator[1]; // vkX.y
        inputPoints[14] = gamma2x1; // gamma2.x.im (Indices deliberately swapped)
        inputPoints[15] = gamma2x0; // gamma2.x.re
        inputPoints[16] = gamma2y1; // gamma2.y.im
        inputPoints[17] = gamma2y0; // gamma2.y.re
        // Pair 4: (C, delta2)
        inputPoints[18] = pC[0];
        inputPoints[19] = pC[1];
        inputPoints[20] = delta2x1; // delta2.x.im (Indices deliberately swapped)
        inputPoints[21] = delta2x0; // delta2.x.re
        inputPoints[22] = delta2y1; // delta2.y.im
        inputPoints[23] = delta2y0; // delta2.y.re

        uint256[1] memory out; // Output buffer for the pairing check result
        bool successPairing;
        // Call the pairing precompile (address 0x08)
        assembly {
            // staticcall(gas, to, inputOffset, inputSize, outputOffset, outputSize)
            successPairing := staticcall(gas(), 0x08, inputPoints, 768, out, 0x20)
        }
        // Require the pairing check precompile call to succeed.
        require(successPairing, "Pairing check precompile failed");
        // Return true if the pairing result is 1 (pairing equation holds).
        return out[0] == 1;
    }
}